
How does it know when the action is complete?

The goal is that instantiation should be the primary interface for plugin developers - not subclassing.

What if ToolbarAction *is* a Handler?

Then it has to define addHooks and removeHooks.

I want there to be a single ToolbarAction class - I don't want there to be different ToolbarAction classes for popup toolbars and control toolbars.

L.Draw.Polyline.extend({
	
});

To what extent should the content 

Maybe ToolbarAction is not the right word.  If we want to consider the toolbar as a UI element and separate the behavior from the appearance - what I want to do is create a sensible container to take care of all of the visual aspects; I don't want to worry about the actual content of the toolbar actions.

This suggests that I should rename ToolbarAction to ToolbarButton
ToolbarButton
ToolbarBox
ToolbarUnit
Tool
ToolbarElement
ToolbarPanel
ToolbarPane
ToolbarObject
ToolbarIcon
TaskTool
ToolIcon

This suggests to me that I probably shouldn't be defining tightly the interface between the action and the button/icon.  The icon shouldn't dictate what the action can be.

In addition, I'm not sure it makes sense to design the ToolbarAction so that the secondary actions are defined as a part of the ToolbarButton.  The secondary actions should be defined on the action itself and the toolbar button should provide a hook that allows secondary actions to be shown and hidden.

Maybe I should provide a Secondary Button class?  Or is the ToolbarButton class good enough for toolbar

Toolbars can be children of toolbars can be children of toolbars....

Allow every ToolbarButton to have children.

I don't want the toolbar action to have to know *anything* about the UI.  Could the toolbar action simply define a method *secondaryActions*.  So that if the toolbar action is a handler, then the getSecondaryActions returns an array of handlers (the secondary actions).

It does seem that there will have to be some kind of contract between the UI element and the action.

The UI element needs to know:
	1. How to activate the toolbar action.
	2. Whether the toolbar action has secondary actions (and, if so, how to activate them).
	3. When the toolbar action is deactivated.

Does L.Handler fit this model?
	1. yes - handlers can be activated with #enable
	2. no
	3. no - unless the the removeHooks method can be modified.

I can handle secondary actions later.

I like the idea that the toolbar takes actions which are passed on to each toolbar button which are passed on to each toolbar action.

Actions should be transferable between different kinds of toolbars.  Shouldn't they?


Using handlers doesn't really seem to solve the problem:
	- handlers are often responsible for disabling themselves
	- handlers don't have listeners that fire when they are added / removed.  Instead, we'll have to modify the class.

what is the problem at stake here?
	- I want to know when an action completes.
	- Maybe toolbar actions should fire an actioncomplete event?  How would the toolbar action know when to fire the actioncomplete event?  It seems like it would be totally dependenton on the implementation of the action itself.  For example, with a handler, actioncomplete should be fired when #disable() is called on the action.


pass L.Toolbar:
	- an array of L.Handler constructors
	- an options object which specifies the options for each L.Handler by name

Each L.Handler is responsible for creating its own icon, passed in via the options hash: i.e.
	- options.icon = { html: '', className: '' }
	- OR it could all be handled by the L.Toolbar and the appearance of the toolbar icon could be set by an option passed in to the toolbar.
	-> problem with this approach is that it seems to separate unecessarily the constructor from the options to be passed to it

Ex. 
new L.Toolbar([
	L.Draw.Polygon,
	L.Draw.Polyline,
	L.Draw.Rectangle,
	L.Draw.Circle,
	L.Draw.Marker
], {
	'draw-polygon': {
		icon: { 
			html: '<span class="glyphicon glyphicon-polygon"></span>'
		},
		fillColor: '#ff0000'
	},
	'draw-polyline': {
		icon: {
			html: '<span class="glyphicon glyphicon-line"></span>'
		},
		fill: false
	}

});

new L.Toolbar(function(map) {
	return [
		new L.Draw.Polygon({

		}),
		new L.Draw.Polyline({
		
		})
	];
});

I would propose for the future of Leaflet.draw:
	* Drawing and editing handlers should not take the map as an argument.  Instead, they should handle the map with an onAdd argument.